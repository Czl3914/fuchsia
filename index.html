<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="generator" content="Asciidoctor 0.1.3">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Fuchsia</title>
<link rel="stylesheet" href="./stylesheets/asciidoc.css">
<link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/7.3/styles/default.min.css">
<script src="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/7.3/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</head>
<body class="article toc2">
<div id="header">
<h1>Fuchsia</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ol type="none" class="sectlevel1">
<li><a href="#_what_can_fuchsia_do_for_me">What can Fuchsia do for me?</a></li>
<li><a href="#_core_concepts">Core concepts</a></li>
<li>
<ol type="none" class="sectlevel2">
<li><a href="#_declarations">Declarations</a></li>
<li><a href="#_discoveries">Discoveries</a></li>
<li><a href="#_processors">Processors</a></li>
<li><a href="#_linkers">Linkers</a></li>
</ol>
</li>
<li><a href="#_installation">Installation</a></li>
<li>
<ol type="none" class="sectlevel2">
<li><a href="#_using_as_maven_dependency">Using as maven dependency</a></li>
<li><a href="#_compiling_a_distribution">Compiling a distribution</a></li>
</ol>
</li>
<li><a href="#_input_output_of_processors">Input-Output of processors</a></li>
<li>
<ol type="none" class="sectlevel2">
<li><a href="#_jax_ws_importer">JAX-WS importer</a></li>
<li><a href="#_mqtt_importer">MQTT importer</a></li>
<li><a href="#_pubsubhubbub_importer">PubSubHubBub importer</a></li>
</ol>
</li>
<li><a href="#_basic">Basic</a></li>
<li>
<ol type="none" class="sectlevel2">
<li><a href="#_creating_a_bundle">Creating a bundle</a></li>
<li><a href="#_import_a_jax_ws_service">Import a JAX-WS service</a></li>
<li><a href="#_import_a_push_service">Import a PuSH service</a></li>
<li><a href="#_import_a_mqtt_service">Import a MQTT service</a></li>
<li><a href="#_exporting_protobuffer_rpc_service">Exporting Protobuffer RPC service</a></li>
<li><a href="#_importing_protobuffer_rpc_service">Importing Protobuffer RPC service</a></li>
<li><a href="#_filebased_discovery">Filebased-Discovery</a></li>
</ol>
</li>
<li><a href="#_tutorial_style">Tutorial Style</a></li>
<li>
<ol type="none" class="sectlevel2">
<li><a href="#_philips_hue_in_fuchsia">Philips hue in Fuchsia</a></li>
<li><a href="#_export_jsonrpc">Export JSONRPC</a></li>
<li><a href="#_import_jsonrpc">Import JSONRPC</a></li>
<li><a href="#_export_jaxws">Export JAXWS</a></li>
<li><a href="#_import_jaxws">Import JAXWS</a></li>
</ol>
</li>
</ol>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_what_can_fuchsia_do_for_me">What can Fuchsia do for me?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Fuchsia can materialize an outcast service (not visible in the OSGi platform) into the OSGi platform. Natively fuchsia can materialize:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>mDNS/DNSSD, bringing up the provider&#8217;s IP and the service type. This allows you to connect directly to the service without having to implement the discovery</p>
</li>
<li>
<p>UPnP services published on the network</p>
</li>
<li>
<p>JAX-WS endpoint, creating an instance of the service in OSGi platform (the interfaces must be available in the platform)</p>
</li>
<li>
<p>JSON-RPC endpoint, makes available into the platform a service for this remote instance, as expected it is mandatory to have the interfaces in order to create the OSGi instance of the endpoint</p>
</li>
<li>
<p>PuSH (PUbSubHubbub) hub, if you have a feed that uses PuSH as hub, all updates are sent via eventAdmin. Thus, avoiding you to implement the protocol</p>
</li>
<li>
<p>MQTT provider, so you can receive your MQTT messages locally (via EventAdmin) without having to implement the subscriber for this protocol</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All those are already built-in features, the materialization of an external service into OSGi platform, this processor is called: <strong>Importer</strong>.</p>
</div>
<div class="paragraph">
<p>The second type of processor is called <strong>Exporter</strong>, this type enables us to turn an OSGi service instance into a service that can be access outside of OSGi, exposed as a web service for instance. The built-in exporters are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>JAX-WS, based in an OSGi service instance, publishes a WebService to be accessed remotely. You can use Fuchsia to instantiate the exported service or use directly <a href="http://cxf.apache.org/">Apache CXF</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Of course those processors (<strong>importers</strong> or <strong>exporters</strong>) are available without needing to code a single line.</p>
</div>
<div class="paragraph">
<p>Albeit, Fuchsia has built-in processors, we are aware that most of applications use their own protocol or adopt their protocol specific device, knowing that Fuchsia was build to be extensible, thus implementing and deploying a customized processor is quite straight forward.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_core_concepts">Core concepts</h2>
<div class="sectionbody">
<div class="paragraph">
<p><span class="image"><a class="image" href="diagram/importer01.svg"><img src="diagram/importer01.svg" alt="Fuchsia" width="1024"></a></span></p>
</div>
<div class="paragraph">
<p>Fuchsia is an extensible tool for integrating external communication protocols inside an OSGi platform. It provides a common interface for creating and managing external connections.</p>
</div>
<div class="paragraph">
<p>As most of modern applications require multiple sources of information such as web services, databases or ubiquitous devices. The integration among those different services become a major issue when dealing with multitude of them.</p>
</div>
<div class="paragraph">
<p>In ubiquitous applications this kind of integration is even more important since the dynamicity and the multitude of protocol grows with number of devices supported.</p>
</div>
<div class="paragraph">
<p>So, developers are suddenly facing the challenge of mastering several protocol, and their respective tools for debugging, dependency managing, native calls access, access configuration, etc. That is where Fuchsia plays a key role, by providing the same way of dealing with different protocols, creating a single entry-point for all protocols supported.</p>
</div>
<div class="paragraph">
<p>In Appsgate all those characteristics are gathered in order to provide an Smart Home environment.</p>
</div>
<div class="paragraph">
<p>You can administrate and monitor all the exchange of your OSGi platform with externals protocols through an unique control panel.</p>
</div>
<div class="ulist">
<div class="title">There exist essentially 4 types of entities inside fuchsia that you need to understand before go hands-on the code:</div>
<ul>
<li>
<p>Declaration, it is the metadata that describes a device or a service</p>
</li>
<li>
<p>Discovery, responsible for the detection of a device/service, in Fuchsia that means create a <strong>Declaration</strong> and adding it to the OSGi registry</p>
</li>
<li>
<p>Processors, it represents the task itself, being split in two types <strong>Importer</strong> or <strong>Exporter</strong></p>
</li>
<li>
<p>Linkers, connects a declaration to a processor, evaluate the constraints to be respected in order to connect those two.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_declarations">Declarations</h3>
<div class="paragraph">
<p>Think in <strong>Declaration</strong> as a property file, although that it is not a file, it is an service registered in an OSGi platform, as long as this service is registered with the proper platform, <strong>Fuchsia</strong> will recognize it.</p>
</div>
<div class="paragraph">
<p>Its function is to indicate that a given device/service is available with certain properties, and is the role of an Importer/Exporter (explained later) to receive those information as inputs and create a bridge between the OSGi platform and this device (all by using the properties given by the <strong>Declaration</strong>), allowing other services to access this device without knowing its protocol.</p>
</div>
</div>
<div class="sect2">
<h3 id="_discoveries">Discoveries</h3>
<div class="paragraph">
<p>As seen before, the way that we inform the Fuchsia platform the existence of a device/service is through a declaration <strong>Declaration</strong>, that can be registered manually of course (since its a service registered in OSGi platform with the interface <strong>org.ow2.chameleon.fuchsia.core.declaration.ImportDeclaration</strong>), but this can be done by fuchsia discoveries, that use specialized discovery protocols to extract all the relevant information of a given service/device and publish in OSGi platform a <strong>Declaration</strong> containing all those informations.</p>
</div>
<div class="ulist">
<div class="title">Available discovery implementations:</div>
<ul>
<li>
<p>Filebased discovery</p>
</li>
<li>
<p>mDNS/DNSsd</p>
</li>
<li>
<p>uPnP</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_processors">Processors</h3>
<div class="sect3">
<h4 id="_importers">Importers</h4>
<div class="paragraph">
<p>In order to trigger <strong>importers</strong> to perform their job, they must to receive an <strong>import declaration</strong> which is configuration (think of it as a key value mapping, just like java properties). The <strong>importation declaration</strong> will recognized by <strong>Fuchsia</strong> as long as they are registered in OSGi with the proper Fuchsia interface (for an importer for example must be <strong>org.ow2.chameleon.fuchsia.core.declaration.ImportDeclaration</strong> )</p>
</div>
<div class="ulist">
<div class="title">Available implementations:</div>
<ul>
<li>
<p>JAX-RS</p>
</li>
<li>
<p>JAX-WS</p>
</li>
<li>
<p>JSON-RPC</p>
</li>
<li>
<p>MQTT</p>
</li>
<li>
<p>PUbSubHubBub</p>
</li>
<li>
<p>Protobuffer RPC</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_exporters">Exporters</h4>
<div class="paragraph">
<p>Analogue to the <strong>importers</strong>, the <strong>exporters</strong> must to receive a <strong>declaration</strong>, but in this case an <strong>export declaration</strong>. But its role is to provide an external access (by external meaning externally to the OSGi platform) to the services available in the current OSGi platform, for instance by publishing a WS.</p>
</div>
<div class="ulist">
<div class="title">Available implementations:</div>
<ul>
<li>
<p>JAX-WS</p>
</li>
<li>
<p>Protobuffer RPC</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_linkers">Linkers</h3>
<div class="paragraph">
<p>The existence of a <strong>declaration</strong> and a <strong>processor</strong> is not enough to trigger a connection between them, there has to exist a <strong>linker</strong>. This <em>linker</em> is responsible to check the condition on both sides (processor and declaration) see if they <em>match</em>, and just then establish a connection between them.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_installation">Installation</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_using_as_maven_dependency">Using as maven dependency</h3>
<div class="paragraph">
<p>Adopting Fuchsia is a straightforward task if you are used to Maven. First we need to add the OW2 maven repository to our list of repositories (as below).</p>
</div>
<div class="listingblock">
<div class="content monospaced">
<pre class="highlight"><code class="xml language-xml">&lt;project ... &gt;
...
&lt;repositories&gt;
	&lt;repository&gt;
		&lt;id&gt;ow2-release&lt;/id&gt;
		&lt;name&gt;OW2-Release&lt;/name&gt;
		&lt;url&gt;http://repository.ow2.org/nexus/content/groups/public/&lt;/url&gt;
	&lt;/repository&gt;
	&lt;repository&gt;
		&lt;id&gt;ow2-snapshot&lt;/id&gt;
		&lt;name&gt;OW2-Snapshot&lt;/name&gt;
		&lt;url&gt;http://repository.ow2.org/nexus/content/repositories/snapshots/&lt;/url&gt;
	&lt;/repository&gt;
&lt;/repositories&gt;
...
&lt;/project&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, we have to declare one or more Fuchsia module <strong>as a maven dependency</strong> of your project.</p>
</div>
<div class="listingblock">
<div class="content monospaced">
<pre class="highlight"><code class="xml language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.ow2.chameleon.fuchsia&lt;/groupId&gt;
    &lt;artifactId&gt;org.ow2.chameleon.fuchsia.core&lt;/artifactId&gt;
    &lt;version&gt;0.0.1&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here we reference the version <strong>0.0.1</strong> of Fuchsia, but of course you can update that version for the version you are willing to use.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note">
</td>
<td class="content">
<div class="title">The catch</div>
<div class="paragraph">
<p>This method is quick and fast to integrate for compilation, although, depending on the importer adopted, it may require 3td party dependencies to be installed in your runtime platform manually. In order to not worry in finding all the dependencies for the importer adopted, you can use <strong>Fuchsia</strong> compilation profiles to gather all the dependencies needed according to your importers.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_compiling_a_distribution">Compiling a distribution</h3>
<div class="paragraph">
<p>In order to generate a Fuchsia distribution there is only one mandatory profile the <strong>core</strong>, all the other modules are optional and can be included in the distribution by adding the appropriate maven profile ( <strong>mvn -P parameter</strong> ). The maven profile and its contents are specified right below.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>core - This module contains all the basic Fuchsia types, fuchsia shell tool is installed automatically in this profile as well, even though its not part of the bundle core</p>
</li>
<li>
<p>discoveries</p>
<div class="ulist">
<ul>
<li>
<p><a href="http://jmdns.sourceforge.net/">mdns</a> - the implementation of dnssd/mdns discovery protocol</p>
</li>
<li>
<p>upnp</p>
</li>
<li>
<p>discovery-filebased</p>
</li>
<li>
<p>discovery-philips-hue</p>
</li>
</ul>
</div>
</li>
<li>
<p>importers</p>
<div class="ulist">
<ul>
<li>
<p>importer-jax-ws</p>
</li>
<li>
<p>importer-philips-hue</p>
</li>
<li>
<p><a href="http://mqtt.org/">mqtt</a></p>
</li>
<li>
<p><a href="https://code.google.com/p/pubsubhubbub/">push</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>exporter</p>
<div class="ulist">
<ul>
<li>
<p>exporter-jaw-ws</p>
</li>
</ul>
</div>
</li>
<li>
<p>tools</p>
<div class="ulist">
<ul>
<li>
<p>grid</p>
</li>
<li>
<p>shell</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_configuration_profiles">Configuration profiles</h4>
<div class="paragraph">
<p>Config profiles are the instantiation of the <em>linker</em> and the <em>processor</em>. Those two tend to be customized, since the filter adopted in the default instantiation of the linker might not be valid for for case</p>
</div>
<div class="ulist">
<ul>
<li>
<p>discoveries:</p>
<div class="ulist">
<ul>
<li>
<p>mdns-config</p>
</li>
</ul>
</div>
</li>
<li>
<p>importers:</p>
<div class="ulist">
<ul>
<li>
<p>importer-cxf-config</p>
</li>
<li>
<p>mqtt-config</p>
</li>
<li>
<p>push-config</p>
</li>
</ul>
</div>
</li>
<li>
<p>exporters:</p>
<div class="ulist">
<ul>
<li>
<p>exporter-cxf-config</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Thus, in order to compile Fuchsia with the <strong>grid</strong>, <strong>exporter-jax-ws</strong> and <strong>mqtt</strong>, would be enough to:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>go to the <strong>distribution</strong> directory</p>
</li>
<li>
<p>type <strong>mvn -Pcore,grid,exporter-jax-ws,mqtt</strong></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>After the compilation process is finished, your Fuchsia distribution is ready to use:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>go to the <strong>distribution/target/chameleon-distribution/</strong></p>
</li>
<li>
<p>type <strong>./chameleon.sh --interactive</strong> (or the apropriate script according to your OS)</p>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_input_output_of_processors">Input-Output of processors</h2>
<div class="sectionbody">
<div class="paragraph">
<p>As seen in [Fuchsia 101](Fuchsia-101), importers use <strong>import declaration</strong> as input. The information contained in the <strong>import declaration</strong> must be enough in order that the processor execute its role properly.</p>
</div>
<div class="sect2">
<h3 id="_jax_ws_importer">JAX-WS importer</h3>
<div class="ulist">
<div class="title">External Requirement:</div>
<ul>
<li>
<p>JAX-WS service published</p>
</li>
<li>
<p>Interface(a') that represents the WSDL available in the OSGi platform that will import the service</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">Import Declaration information required:</div>
<ul>
<li>
<p>jax-ws.importer.interfaces</p>
</li>
<li>
<p>className</p>
</li>
<li>
<p>endpoint.url</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">Output:</div>
<ul>
<li>
<p>OSGi service registered with a' representing the JAX-WS (Remote service)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Detailed Description</strong></p>
</div>
<div class="paragraph">
<p>Today to import the JAX-WS service Fushsia uses <a href="http://cxf.apache.org/">CXF</a>. CXF is used in order to reduce the complexity in creating the connection and handling with different issues that may be raised.</p>
</div>
</div>
<div class="sect2">
<h3 id="_mqtt_importer">MQTT importer</h3>
<div class="ulist">
<div class="title">External Requirement:</div>
<ul>
<li>
<p>MQTT server with the address known</p>
</li>
<li>
<p>EventAdmin service configured in the machine that will import this service</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">Import Declaration information required:</div>
<ul>
<li>
<p>id</p>
</li>
<li>
<p>mqtt.queue</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">Output:</div>
<ul>
<li>
<p>A message will be published in EventAdmin in the queue $mqtt.queue, meaning that it will use the same name of <strong>queue</strong> as MQTT</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Detailed Description</strong></p>
</div>
<div class="paragraph">
<p><a href="http://mqtt.org/">MQTT</a> is a protocol <a href="http://openiot.eu/">largely diffused</a> protocol for message exchange due to its good performance. The implementation used by Fuchsia to support MQTT was <a href="http://www.rabbitmq.com/">RabbitMQ</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_pubsubhubbub_importer">PubSubHubBub importer</h3>
<div class="paragraph">
<p><a href="http://code.google.com/p/pubsubhubbub/">PubSubHubBub</a>, or simply <strong>PuSH</strong>, is a publish/subscribe protocol created by google and used by some of its <a href="http://code.google.com/p/pubsubhubbub/wiki/HubbubAtGoogle">tools</a>.</p>
</div>
<div class="ulist">
<div class="title">External Requirement:</div>
<ul>
<li>
<p>PuSh server address</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">Import Declaration information required:</div>
<ul>
<li>
<p>push.hub.url</p>
</li>
<li>
<p>push.hub.topic</p>
</li>
<li>
<p>push.subscriber.callback</p>
</li>
<li>
<p>push.eventAdmin.queue</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">Output:</div>
<ul>
<li>
<p>A message will be published in EventAdmin in the queue $push.eventAdmin.queue, meaning that it will use the same name of <strong>queue</strong> as PuSH</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Detailed Description</strong></p>
</div>
<div class="paragraph">
<p>There are no well known and portable PuSH implementations, Fuchsia implemented partially <a href="https://pubsubhubbub.googlecode.com/git/pubsubhubbub-core-0.4.html">PuSH specification</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_basic">Basic</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_creating_a_bundle">Creating a bundle</h3>
<div class="paragraph">
<p>We can use maven plugin to create an iPOJO artifact.</p>
</div>
<div class="listingblock">
<div class="content monospaced">
<pre class="highlight"><code class="bash language-bash">mvn org.apache.maven.plugins:maven-archetype-plugin:generate \
-DinteractiveMode=false \
-DarchetypeArtifactId=maven-ipojo-plugin \
-DarchetypeGroupId=org.apache.felix \
-DarchetypeVersion=1.11.0 \
-DartifactId=config \
-DgroupId=org.adele \
-Dpackage=org.adele \
-Dversion=0.0.1-EXAMPLE</code></pre>
</div>
</div>
<div class="paragraph">
<p>Make sure to add <strong>Fuchsia</strong> dependency:</p>
</div>
<div class="listingblock">
<div class="content monospaced">
<pre class="highlight"><code class="xml language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.ow2.chameleon.fuchsia&lt;/groupId&gt;
    &lt;artifactId&gt;org.ow2.chameleon.fuchsia.core&lt;/artifactId&gt;
    &lt;version&gt;0.0.1&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>That is it, now you are ready to add your custom code.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<img src="./images/icons/warning.png" alt="Warning">
</td>
<td class="content">
<div class="paragraph">
<p>Make sure to replace the version <strong>0.0.1</strong> of Fuchsia, by the version that you are using</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_import_a_jax_ws_service">Import a JAX-WS service</h3>
<div class="paragraph">
<p>After create your project, we have couple tasks to accomplish before be able to use the imported JAX-WS service:</p>
</div>
<div class="ulist">
<div class="title">Prepare the environment</div>
<ul>
<li>
<p>[ ] Instantiate the importer</p>
</li>
<li>
<p>[ ] Instantiate the linker</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">As result of fuchsia</div>
<ul>
<li>
<p>[ ] Inform fuchsia the JAX-WS info</p>
</li>
<li>
<p>[ ] Fetch your local instance</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_preparation">Preparation</h4>
<div class="paragraph">
<p>One step at a time, so lets first instantiate our importer, we first need to find out the name of our importer JAX-WS, which is <em>org.ow2.chameleon.fuchsia.importer.jaxws.JAXWSImporter</em>, with that in mind we can instantiate it indicating what are the <strong>Declarations</strong> that he should consider as a declaration that concerns it.</p>
</div>
<div class="paragraph">
<p>In our case we may say that, any declaration containing a value for the key <strong>endpoint.url</strong>, is a valid declaration to be processed by this importer, thus this give us:</p>
</div>
<div class="listingblock">
<div class="content monospaced">
<pre class="highlight"><code>    Instance cxfimporter = Instance.instance()
            .of("org.ow2.chameleon.fuchsia.importer.jaxws.JAXWSImporter")
            .with("target").setto("(endpoint.url=*)");</code></pre>
</div>
</div>
<div class="paragraph">
<p>With this we can check our first task <strong>Instantiate the importer</strong>. Following our list we have instantiated the <strong>Linker</strong>.</p>
</div>
<div class="paragraph">
<p>The <strong>Linkers</strong> job is to evaluate if a given <strong>Declaration</strong> and a <strong>Service</strong> match together, so essentially he impose the condition in order to connect this two entities. We can instantiate our linker in following manner:</p>
</div>
<div class="listingblock">
<div class="content monospaced">
<pre class="highlight"><code>    Instance cxfimporterlinker = instance()
            .of(FuchsiaConstants.DEFAULT_IMPORTATION_LINKER_FACTORY_NAME)
            .with("fuchsia.linker.filter.importDeclaration").setto("(endpoint.url=*)")
            .with("fuchsia.linker.filter.importerService").setto("(instance.name=cxfimporterlinker)");</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this linker we are saying "if a declaration contains <em>endpoint.url</em> than connect it with the importer in which the instance is called <em>cxfimporterlinker</em>".</p>
</div>
<div class="paragraph">
<p>In order to <em>Inform fuchsia the JAX-WS info</em>, we have several options, either we can publish a service that follows the interface <em>org.ow2.chameleon.fuchsia.core.declaration.ImportDeclaration</em>, or we can use the Filebased-Discovery, which translate files deployed in the folder named <em>load</em> into a ImportDeclaration.</p>
</div>
<div class="paragraph">
<p>You can check that everything is up and running by typing <strong>importer</strong> on the console, you should see at least:</p>
</div>
<div class="listingblock">
<div class="content monospaced">
<pre class="highlight"><code>Importer [cxfimporter] provided by bundle org.ow2.chameleon.fuchsia.importer.jax-rs (46)
	*importer name = cxfimporter
	Service properties:
		factory.name = org.ow2.chameleon.fuchsia.importer.jaxws.JAXWSImporter
		instance.name = cxfimporter
		objectClass = [Ljava.lang.String;@191c428
		service.id = 335
		target = (endpoint.url=*)</code></pre>
</div>
</div>
<div class="paragraph">
<p>And check that the FilebasedDiscovery is running as well by typing <strong>discovery</strong> and you will see:</p>
</div>
<div class="listingblock">
<div class="content monospaced">
<pre class="highlight"><code>Discovery [Fuchsia-FilebasedDiscovery] provided by bundle fuchsia-filebased-discovery (37)
	Service properties:
		factory.name = Fuchsia-FilebasedDiscovery-Factory
		fuchsia.system.filebased.discovery.directory = load
		fuchsia.system.filebased.discovery.polling = 2000
		instance.name = Fuchsia-FilebasedDiscovery
		objectClass = [Ljava.lang.String;@20e9c6
		service.id = 321
</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_result">Result</h4>
<div class="paragraph">
<p>So far we&#8217;ve our checklist look like this:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>[*] Instantiate the importer</p>
</li>
<li>
<p>[*] Instantiate the linker</p>
</li>
<li>
<p>[ ] Inform fuchsia the JAX-WS info</p>
</li>
<li>
<p>[ ] Use the remote instance</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The last two steps consist in informing the Fuchsia the address of our JAX-WS service. For that its enough to deploy a file in the folder <em>load</em> (thanks to the Filebased-Discovery) with the following content:</p>
</div>
<div class="listingblock">
<div class="content monospaced">
<pre class="highlight"><code>id=virtual-camera
className=org.ow2.chameleon.fuchsia.exporter.cxf.examples.base.PojoSampleToBeExportedIface
jax-ws.importer.interfaces=[org.ow2.chameleon.fuchsia.exporter.cxf.examples.base.PojoSampleToBeExportedIface]
endpoint.url=http://localhost:8080/cxf/service/PojoSampleToBeExportedIface

deviceType=camera
deviceSubType=another
device.serialNumber=virtual-camera</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then, just request your service as a regular dependency (as shown below), then you will see your dependency being injected and ready for use without much trouble.</p>
</div>
<div class="listingblock">
<div class="content monospaced">
<pre class="highlight"><code class="java language-java">@Component
@Instantiate
public class Client {

    @Requires
    PojoSampleToBeExportedIface myRemoteService;

    @Validate
    public void validate(){

        System.out.println("----&gt;"+myRemoteService.getMessage2());

    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_import_a_push_service">Import a PuSH service</h3>
<div class="paragraph">
<p>PubSubHubbub (PuSH) is a google protocol create to be fast, in fact it is a publish / subscribe mechanism that avoids the polling technique. A small diagram can show you the idea behind the protocol</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="diagram/push01.svg" alt="PuSH" width="800"></span></p>
</div>
<div class="sect3">
<h4 id="_prepare">Prepare</h4>
<div class="paragraph">
<p>So we are going to need, we are assuming that the publisher and hub addresses are well known.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>[*] know the address of the publisher</p>
</li>
<li>
<p>[*] know the address of the hub</p>
</li>
<li>
<p>[ ] Instantiate the Importer</p>
</li>
<li>
<p>[ ] Instantiate the linker</p>
</li>
<li>
<p>[ ] Inform fuchsia the Hub and Publisher addresses</p>
</li>
<li>
<p>[ ] Visualize the messages</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The first two steps you have to know already those addresses, the next two steps can be done by using maven profile. Meaning that we can generate a chameleon distribution with all our fuchsia dependencies, linker and importer instantiated just by typing into the project repository:</p>
</div>
<div class="listingblock">
<div class="content monospaced">
<pre class="highlight"><code class="bash language-bash">mvn clean install -f distribution/pom.xml -Pcore,push,push-config,discovery-filebased &amp;&amp; \
cd distribution/target/chameleon-distribution/ &amp;&amp; \
sh chameleon.sh --interactive</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now lets verify our checklist:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>[*] know the address of the publisher</p>
</li>
<li>
<p>[*] know the address of the hub</p>
</li>
<li>
<p>[*] Instantiate the Importer</p>
</li>
<li>
<p>[*] Instantiate the linker</p>
</li>
<li>
<p>[*] Inform fuchsia the Hub and Publisher addresses</p>
</li>
<li>
<p>[ ] Visualize the messages</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The next step is done by add a file with all the information we already have about the PuSH server (example of the file below)</p>
</div>
<div class="listingblock">
<div class="content monospaced">
<pre class="highlight"><code class="bash language-bash">id=push-dispatch-event-admin
deviceType=camera
deviceSubType=another

push.hub.topic=http://blogname.blogspot.com/feeds/posts/default
push.hub.url=http://localhost:8080/hub/subscribe
push.subscriber.callback=http://localhost:8080/push
push.eventAdmin.queue=public

device.serialNumber=push-dispatch-event-admin</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<img src="./images/icons/warning.png" alt="Warning">
</td>
<td class="content">
<div class="paragraph">
<p>The client must be accessible from the hub, since the hub is the one that pushes the change into clients callback</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>So we are able to see the redirection (from PuSH into Event admin) we install <a href="http://www.interior-dsgn.com/apache//felix/org.apache.felix.webconsole.plugins.event-1.1.0.jar">Web Console Event Admin Plugin</a>.</p>
</div>
<div class="paragraph">
<p>By default fuchsia distribution will install the <em>felix webconsole</em>, that can be access in the URL <a href="http://localhost:8080/system/console/events">http://localhost:8080/system/console/events</a>.</p>
</div>
<div class="paragraph">
<p>Now when you receive an update from the <em>Hub</em> it will be automatically redirected to eventAdmin message bus.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_import_a_mqtt_service">Import a MQTT service</h3>
<div class="paragraph">
<p>As MQTT is an efficient message exchange protocol, Fuchsia has built in a <strong>MQTT</strong> importer that receives and forward messages from MQTT bus into EventAdmin bus.</p>
</div>
<div class="paragraph">
<p>The address of the MQTT server is supposedly known, and the next two steps (importer and linker instantiation) can be done with the maven profile, according to the command below.</p>
</div>
<div class="listingblock">
<div class="content monospaced">
<pre class="highlight"><code class="bash language-bash">mvn clean install -f distribution/pom.xml -Pcore,mqtt,mqtt-config,discovery-filebased &amp;&amp; \
cd distribution/target/chameleon-distribution/ &amp;&amp; \
sh chameleon.sh --interactive</code></pre>
</div>
</div>
<div class="paragraph">
<p>So lets verify how are we in relation to our checklist:</p>
</div>
<div class="paragraph">
<p>Lets create our checklist:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>[*] know the address of the MQTT server</p>
</li>
<li>
<p>[*] Instantiate the Importer</p>
</li>
<li>
<p>[*] Instantiate the linker</p>
</li>
<li>
<p>[ ] Inform fuchsia about the MQTT server address</p>
</li>
<li>
<p>[ ] Visualize the messages</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>We tell Fuchsia which MQTT server (and other parameters) by deploying a file into the <em>load</em> directory containing those info (with the content below):</p>
</div>
<div class="listingblock">
<div class="content monospaced">
<pre class="highlight"><code class="bash language-bash">id=mqtt-dispatch-event-admin
deviceType=camera
deviceSubType=another

mqtt.queue=public
mqtt.server.host=localhost
mqtt.server.port=5672</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can use <a href="http://localhost:8080/system/console/event">WebConsole</a> to see all the messages that come from MQTT and redirected to <strong>EventAdmin</strong>. The information <strong>mqtt.server.host</strong> and <strong>mqtt.server.port</strong> are optional, in case those informations are not available it will use the information defined as default by <strong>RabbitMQ</strong>.</p>
</div>
<div class="paragraph">
<p>So, after installing your MQTT server (in our case RabbitMQ) make sure its running</p>
</div>
<div class="listingblock">
<div class="content monospaced">
<pre class="highlight"><code class="bash language-bash">sudo /etc/init.d/rabbitmq-server status</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_exporting_protobuffer_rpc_service">Exporting Protobuffer RPC service</h3>
<div class="paragraph">
<p>In order to be able to export your <a href="https://code.google.com/p/protobuf/">Protobuffer</a> Service, feel things need to be done:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>[ ] Protobuffer class generated (Step 1)</p>
</li>
<li>
<p>[ ] Implement the service methods for the Protobuffer generated class (Step 2)</p>
</li>
<li>
<p>[ ] Protobuffer class instance added to OSGi Registry (Step 3)</p>
</li>
<li>
<p>[ ] Instantiate the exporter and the linker (Step 4)</p>
</li>
<li>
<p>[ ] Declare the exportation (Step 5)</p>
</li>
<li>
<p>[ ] Create the runtime platform (Step 6)</p>
</li>
</ul>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<img src="./images/icons/warning.png" alt="Warning">
</td>
<td class="content">
<div class="paragraph">
<p>Protobuffer <strong>version 2.5.0</strong> must be used, any version other than that may produce errors in the remote call</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_step_1">Step 1</h4>
<div class="paragraph">
<p>Follow the installation procedure in <a href="https://code.google.com/p/protobuf/">Protobuffer</a> website to get the command for compile <em>.proto</em> file.</p>
</div>
<div class="paragraph">
<p>Here it is an example of a proto file that can be used for a first glance at the functionality.</p>
</div>
<div class="listingblock">
<div class="content monospaced">
<pre class="highlight"><code class="bash language-bash">
package tutorial;

option java_package = "com.google.code.cxf.protobuf.addressbook";
option java_outer_classname = "AddressBookProtos";

message Person {
  required string name = 1;
  required int32 id = 2;        // Unique ID number for this person.
  optional string email = 3;

  enum PhoneType {
    MOBILE = 0;
    HOME = 1;
    WORK = 2;
  }

  message PhoneNumber {
    required string number = 1;
    optional PhoneType type = 2 [default = HOME];
  }

  repeated PhoneNumber phone = 4;
}

message AddressBook {
  repeated Person person = 1;
}

service AddressBookService {
  rpc addPerson(Person) returns(AddressBookSize);
  rpc listPeople(NamePattern) returns(AddressBook);
}

message AddressBookServiceMessage {
  optional Person addPerson = 1;
  optional NamePattern listPeople = 2;
}

message AddressBookSize {
  optional int32 size = 1;
}

message NamePattern {
  optional string pattern = 1;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>From this file you can generate your class by invoking</p>
</div>
<div class="listingblock">
<div class="content monospaced">
<pre class="highlight"><code class="bash language-bash">protoc --java_out=src/main/java/ addressbook.proto</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_step_2">Step 2</h4>
<div class="paragraph">
<p>When <em>rpc service</em> is declared in the <em>proto</em> file, this will generate an interface that <strong>must</strong> to be implemented in order that this rpc service can be called. Since the <em>proto</em> file is not a language, we cannot define what the method should to at this point, it is pretty logic, right?</p>
</div>
<div class="paragraph">
<p>So in our case we should implement two methods <strong>addPerson</strong> and <strong>listPeople</strong>, the exactly two services declared in the <em>proto</em> file.</p>
</div>
<div class="listingblock">
<div class="content monospaced">
<pre class="highlight"><code class="java language-java">public class AddressBookServiceImpl extends AddressBookProtos.AddressBookService {
    Map&lt;Integer, AddressBookProtos.Person&gt; records = new ConcurrentHashMap&lt;Integer, AddressBookProtos.Person&gt;();

    public void listPeople(RpcController controller,
                           AddressBookProtos.NamePattern request, RpcCallback&lt;AddressBookProtos.AddressBook&gt; done) {
	...
    }

    public void addPerson(RpcController controller,
                          AddressBookProtos.Person request, RpcCallback&lt;AddressBookProtos.AddressBookSize&gt; done) {
        ...
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>An example of body for these two methods can be:</p>
</div>
<div class="listingblock">
<div class="content monospaced">
<pre class="highlight"><code class="java language-java">public class AddressBookServiceImpl extends AddressBookProtos.AddressBookService {
    Map&lt;Integer, AddressBookProtos.Person&gt; records = new ConcurrentHashMap&lt;Integer, AddressBookProtos.Person&gt;();

    public void listPeople(RpcController controller,
                           AddressBookProtos.NamePattern request, RpcCallback&lt;AddressBookProtos.AddressBook&gt; done) {
        AddressBookProtos.AddressBook.Builder addressbook = AddressBookProtos.AddressBook
                .newBuilder();

        for (AddressBookProtos.Person person : records.values()) {
            if (person.getName().indexOf(request.getPattern()) &gt;= 0) {
                addressbook.addPerson(person);
            }
        }

        done.run(addressbook.build());
    }

    public void addPerson(RpcController controller,
                          AddressBookProtos.Person request, RpcCallback&lt;AddressBookProtos.AddressBookSize&gt; done) {
        if (records.containsKey(request.getId())) {
            System.out.println("Warning: will replace existing person: " + records.get(request.getId()).getName());
        }
        records.put(request.getId(), request);
        done.run(AddressBookProtos.AddressBookSize.newBuilder().setSize(
                records.size()).build());
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, its not something straight forward as you thought it should be.</p>
</div>
</div>
<div class="sect3">
<h4 id="_step_3">Step 3</h4>
<div class="paragraph">
<p>In this step, we instantiate our service (in java level) and publish it in the OSGi registry. There are several ways of doing this <strong>Step</strong> so pick up your flavor. We will do like this:</p>
</div>
<div class="listingblock">
<div class="content monospaced">
<pre class="highlight"><code class="java language-java">@Component
@Instantiate
public class RegisterBookService {

    ...

    @Validate
    public void validate(){

        Dictionary serviceProperties=new Hashtable&lt;String,Object&gt;();

        context.registerService(
		new String[]{com.google.protobuf.Service.class.getName(),AddressBookProtos.AddressBookService.class.getName()},
		new AddressBookServiceImpl(),
		serviceProperties);

    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This procedure will allow the fuchsia exporter to fetch this instance and export it.</p>
</div>
</div>
<div class="sect3">
<h4 id="_step_4">Step 4</h4>
<div class="paragraph">
<p>As you should have seen in previous sections, the <strong>exporter</strong> (for our case) and a <strong>linker</strong> must be instantiated, they are not instantiated automatically.</p>
</div>
<div class="listingblock">
<div class="content monospaced">
<pre class="highlight"><code class="java language-java">@Configuration
public class Config {
    Instance ProtobufferExporter = instance()
            .of("org.ow2.chameleon.fuchsia.exporter.protobuffer.ProtobufferExporter")
            .with("target").setto("(rpc.export.address=*)");

    Instance ProtobufferExporterLinker = instance()
            .of(FuchsiaConstants.DEFAULT_EXPORTATION_LINKER_FACTORY_NAME)
            .with(ExportationLinker.FILTER_EXPORTDECLARATION_PROPERTY).setto("(rpc.export.address=*)")
            .with(ExportationLinker.FILTER_EXPORTERSERVICE_PROPERTY).setto("(instance.name=ProtobufferExporter)");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>See that the filters can be customized, they defined the <strong>export declaration</strong> that should be catch by this exporter.</p>
</div>
</div>
<div class="sect3">
<h4 id="_step_5">Step 5</h4>
<div class="paragraph">
<p>The <strong>export declaration</strong> is the intention, in fact it is this file that you express to the framework "Look, i have X instance, and i would like to expose (export) that instance as a Protobuffer RPC service".</p>
</div>
<div class="paragraph">
<p>This sentenced is converted in:</p>
</div>
<div class="listingblock">
<div class="content monospaced">
<pre class="highlight"><code class="java language-java">@Component
@Instantiate
public class ExportDeclaration {

    ...

    @Validate
    public void validate(){

        Map&lt;String, Object&gt; metadata=new HashMap&lt;String, Object&gt;();

        metadata.put("id","export-tests");
        metadata.put("exporter.id","myservice");
        metadata.put("rpc.export.address","http://localhost:8889/AddressBookService");
        metadata.put("rpc.export.class","org.ow2.chameleon.fuchsia.protobuffer.protoclass.AddressBookProtos$AddressBookService");
        metadata.put("rpc.export.message","org.ow2.chameleon.fuchsia.protobuffer.protoclass.AddressBookProtos$AddressBookServiceMessage");

        org.ow2.chameleon.fuchsia.core.declaration.ExportDeclaration declaration = ExportDeclarationBuilder.fromMetadata(metadata).build();

        Dictionary&lt;String, Object&gt; props = new Hashtable&lt;String, Object&gt;();

        String clazzes[] = new String[]{org.ow2.chameleon.fuchsia.core.declaration.ExportDeclaration.class.getName()};
        ServiceRegistration registration = context.registerService(clazzes, declaration, props);

    }

}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_step_6">Step 6</h4>
<div class="paragraph">
<p>Assuming that you have compiled fuchsia (in previous sections), you can use <strong>distribution</strong> module to generate a distribution with dependencies needed.</p>
</div>
<div class="listingblock">
<div class="content monospaced">
<pre class="highlight"><code class="java language-java">mvn clean install -Pcore,discovery-filebased,protobuffer &amp;&amp; cd target/chameleon-distribution &amp;&amp; \
sh chameleon.sh --interactive</code></pre>
</div>
</div>
<div class="paragraph">
<p>To verify that everything was published properly, it is enough to access the url <a href="http://localhost:8889/AddressBookService?proto">http://localhost:8889/AddressBookService?proto</a> (pay attention that the base url is the same URL we declared in out metadata file)</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_importing_protobuffer_rpc_service">Importing Protobuffer RPC service</h3>
<div class="paragraph">
<p>Here, we can see the similarity in the importation process, if a given protocol is supported by Fuchsia the processors are used similarly independently of the protocol.</p>
</div>
<div class="ulist">
<div class="title">Prepare the environment</div>
<ul>
<li>
<p>[ ] Instantiate the importer &amp; linker (Step 1)</p>
</li>
<li>
<p>[ ] Publish your intention, in fuchsia the <strong>declaration</strong> (Step 2)</p>
</li>
<li>
<p>[ ] Fetch your local instance (Step 3)</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_step_1_2">Step 1</h4>
<div class="paragraph">
<p>This step is mandatory for use of <strong>processors</strong> (importer, exporter). From the moment you instantiate one processor, it is usually required for you to create a <strong>linker</strong> otherwise your service cannot be notified in case of a <strong>declaration</strong> appearance.</p>
</div>
<div class="listingblock">
<div class="content monospaced">
<pre class="highlight"><code class="java language-java">@Configuration
public class ProtobufferImporterConfig {
	    Instance ProtobufferRPCImporter = instance()
		    .of("org.ow2.chameleon.fuchsia.importer.protobuffer.ProtobufferImporter")
		    .with("target").setto("(&amp;(rpc.server.address=*)(rpc.proto.class=*)(rpc.proto.service=*)(rpc.proto.message=*))");

	    Instance ProtobufferRPCLinker = instance()
		    .of(FuchsiaConstants.DEFAULT_IMPORTATION_LINKER_FACTORY_NAME)
		    .with(ImportationLinker.FILTER_IMPORTDECLARATION_PROPERTY).setto("(&amp;(rpc.server.address=*)(rpc.proto.class=*)(rpc.proto.service=*)(rpc.proto.message=*))")
		    .with(ImportationLinker.FILTER_IMPORTERSERVICE_PROPERTY).setto("(instance.name=ProtobufferRPCImporter)");
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_step_2_2">Step 2</h4>
<div class="listingblock">
<div class="content monospaced">
<pre class="highlight"><code class="java language-java">id=cxf-protobuffer-importer

deviceType=camera
deviceSubType=another
device.serialNumber=virtual-camera

rpc.server.address=http://localhost:8889/AddressBookService
rpc.proto.class=org.ow2.chameleon.fuchsia.protobuffer.protoclass.AddressBookProtos
rpc.proto.service=AddressBookService
rpc.proto.message=AddressBookServiceMessage</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_step_3_2">Step 3</h4>
<div class="paragraph">
<p>Now, you are ready to go, the only thing you have to do now is to annotate your dependency as usual, and enjoy it.</p>
</div>
<div class="paragraph">
<p>As always here is it the example we put to work:</p>
</div>
<div class="listingblock">
<div class="content monospaced">
<pre class="highlight"><code class="java language-java">@Component
@Instantiate
public class BookClient {

    private final BundleContext context;

    @Requires (filter = "(fuchsia.importer.id=cxf-protobuffer-importer)")
    AddressBookProtos.AddressBookService addressBook;

    public BookClient(BundleContext context){
        this.context=context;
    }


    @Validate
    public void validate(){

        SimpleRpcController controller = new SimpleRpcController();

        AddressBookProtos.Person.Builder person = AddressBookProtos.Person.newBuilder();

        person.setId(1);
        person.setName("Alice");
        AddressBookProtos.Person alice = person.build();

        addressBook.addPerson(controller, alice, new RpcCallback&lt;AddressBookProtos.AddressBookSize&gt;() {
            public void run(AddressBookProtos.AddressBookSize size) {
                System.out.println("\nThere are " + size.getSize()
                        + " person(s) in the address book now.");
            }
        });

        controller.reset();

        System.out.println("\nSearching for people with 'A' in their name.");
        addressBook.listPeople(controller, AddressBookProtos.NamePattern.newBuilder().setPattern("A")
                .build(), new RpcCallback&lt;AddressBookProtos.AddressBook&gt;() {
            public void run(AddressBookProtos.AddressBook response) {

                System.out.println("\nList of people found: \n");

                for (AddressBookProtos.Person person : response.getPersonList()) {

                    System.out.println("--&gt;" + person.getName());

                }


            }
        });

    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The only reason we added the filter in <strong>@Required</strong> was to make sure that the remote instance (created by imported) is injected. So this is not mandatory in regular cases.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_filebased_discovery">Filebased-Discovery</h3>
<div class="paragraph">
<p>First things first, in order to have an discovery we need to create a fuchsia distribution that embeds it, or to use an already existing distribution and add the modules required. Below we will show you how to use couples of discoveries that are available in the platform.</p>
</div>
<div class="sect3">
<h4 id="_what_it_does">What it does?!</h4>
<div class="paragraph">
<p>As seen in the introduction the fundamental task of a discovery is to create an instance of Declaration which represents the availability of a service/device, and the intrinsic information of such service/device are contained inside <strong>Declaration</strong> as properties (stored in a Map).</p>
</div>
<div class="paragraph">
<p>The idea behind having a filebased discovery, is in fact be able to deploy a file (property file style, containing key value mapping).</p>
</div>
<div class="paragraph">
<p>In order to activate the filebased discovery its enough to compile the distribution with the profile <strong>discovery-filebased</strong> (meaning mvn clean install -Pcore,discovery-filebased), from the moment you compile a distribution with this parameter and you launch this distribution a directory called <strong>load</strong> will be created in the root of the chameleon distribution ($FUCHSIA/distribution/target/chameleon-distribution), this directory will be used to deploy your files that contain the key-value that you need to be instantiated in the platform.</p>
</div>
<div class="paragraph">
<p>An example of such file is this one:</p>
</div>
<div class="listingblock">
<div class="content monospaced">
<pre class="highlight"><code>id=mqtt-dispatch-event-admin
exporter.id=camera-exporter

deviceType=camera
deviceSubType=another

mqtt.queue=public</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you type <strong>declaration</strong> in the console you should see:</p>
</div>
<div class="listingblock">
<div class="content monospaced">
<pre class="highlight"><code>Service properties:
		objectClass = [Ljava.lang.String;@26f6a1
		service.id = 319
Metadata
	id=mqtt-dispatch-event-admin
	deviceType=camera
	deviceSubType=another
	exporter.id=camera-exporter
	mqtt.queue=public</code></pre>
</div>
</div>
<div class="paragraph">
<p>This indicated that the file that you have just deployed have been read and turned into a declaration.</p>
</div>
</div>
<div class="sect3">
<h4 id="_mdns">mDNS</h4>
<div class="paragraph">
<p>mDNS is a discovery protocol based on the previous Bonjour(c), from Apple. To perform a simple test of such protocol, its enough to compile a fuchsia distribution with the following parameters:</p>
</div>
<div class="paragraph">
<p><em>mvn clean install -Pcore,mdns,mdns-config</em></p>
</div>
<div class="paragraph">
<p>core and mdns are the modules that we need, in this case, the fuchsia core types and the discovery module itself. The 3td element <em>mdns-config</em> is the element responsible to configure the discovery. Even though the <strong>mdns</strong> module is available with the -Pmdns profile, it is necessary to create an instance of it, shaping it as we wish. We will explain in few paragraphs how to do that manually, but for now we will use an configuration example that setup the discovery to find out all the printers available in the local network, for that we add the profile -Pmdns-config.</p>
</div>
<div class="paragraph">
<p>To verify that the discovery works properly you can use the console.</p>
</div>
<div class="paragraph">
<p>If you type <strong>declaration</strong> on the console you should see an output similar to this:</p>
</div>
<div class="paragraph">
<p>You should see all your printers in form of:</p>
</div>
<div class="listingblock">
<div class="content monospaced">
<pre class="highlight"><code>Metadata
	id=hp LaserJet 2300 (scribe missions)
	discovery.mdns.device.name=hp LaserJet 2300 (scribe missions)
Metadata
	id=HP LaserJet 600 M602 [2F0B40]
	discovery.mdns.device.name=HP LaserJet 600 M602 [2F0B40]
	Service properties:
		objectClass = [Ljava.lang.String;@fcc720
		service.id = 312
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>And if you type <strong>discovery</strong> in the console you should see:</p>
</div>
<div class="listingblock">
<div class="content monospaced">
<pre class="highlight"><code>Discovery [DNSSDDiscovery] provided by bundle mdns (19)
	Service properties:
		dnssd.service.type = _printer._tcp.local.
		factory.name = DNSSDDiscoveryFactory
		instance.name = DNSSDDiscovery
		objectClass = [Ljava.lang.String;@1db4108
		service.id = 301</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this approach we used a configuration that was available in Fuchsia. But that is not usually the case; most of the time we are required to instantiate the discovery ourselves configure the filter in a way that is the application need it.</p>
</div>
<div class="paragraph">
<p>The following configuration that makes available to import all the printers on the local network inside the platform with requiring any other information than the type of the device that interest us.</p>
</div>
<div class="listingblock">
<div class="content monospaced">
<pre class="highlight"><code class="java language-java">@Configuration
public class DNSSDInitializer {
    Instance dnssdDiscovery = instance()
            .of("DNSSDDiscoveryFactory")
            .named("DNSSDDiscovery")
            .with("dnssd.service.type").setto("_printer._tcp.local.");

}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<img src="./images/icons/tip.png" alt="Tip">
</td>
<td class="content">
<div class="paragraph">
<p>This instance can be created in any fashion, as long as it is an <a href="http://www.ipojo.org">iPOJO</a> instance.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_tutorial_style">Tutorial Style</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_philips_hue_in_fuchsia">Philips hue in Fuchsia</h3>
<div class="sect3">
<h4 id="_description">Description</h4>
<div class="paragraph">
<p>We are ready to use Philips Hue, simply by:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>deploying a philips hue discovery - detects the presense of a Philips Hue bridge and authenticates on it.</p>
</li>
<li>
<p>deploying a philips hue importer - makes the lamp accessible by OSGi</p>
</li>
<li>
<p>configure a linker between the discovery and importer</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>And at each step you can verify that they were correctly deployed, this is the biggest advantage of using Fuchsia as a device framework.</p>
</div>
</div>
<div class="sect3">
<h4 id="_building_the_platform">Building the platform</h4>
<div class="paragraph">
<p>In order to build the platform you are going to download the <a href="https://github.com/ow2-chameleon/fuchsia/">source code</a>. Then you need two other steps:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>mvn clean install #compiles the project</p>
</li>
<li>
<p>mvn -f distribution/pom.xml clean install -Pcore,discovery-philips-hue,importer-philips-hue #creates a distribution with all philips base code</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The only thing left to do is to start your platform, on directory <em>distribution/target/chameleon-distribution</em> launch the application:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>sh chameleon.sh --interactive</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>That is it, at this point you have all the platform running, now you need to declare your <strong>intentions</strong>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_declaring_intentions">Declaring intentions</h4>
<div class="paragraph">
<p>This is done by java code, you have to deploy a bundle in the platform that creates the intentions, which is basically instantiate the components: discovery, importer and the linkers. This can be done with the code below:</p>
</div>
<div class="listingblock">
<div class="content monospaced">
<pre class="highlight"><code>@Configuration
public class Config {

    Instance philipsBridgeImporter = instance()
            .of("org.ow2.chameleon.fuchsia.importer.philipshue.PhilipsHueBridgeImporter");

    Instance philipsImporter = instance()
            .of("org.ow2.chameleon.fuchsia.importer.philipshue.PhilipsHueImporter");

    Instance philipsLinkerBridge = instance()
            .of(FuchsiaConstants.DEFAULT_IMPORTATION_LINKER_FACTORY_NAME)
            .with(ImportationLinker.FILTER_IMPORTDECLARATION_PROPERTY).setto("(discovery.philips.bridge.type=*)")
            .with(ImportationLinker.FILTER_IMPORTERSERVICE_PROPERTY).setto("(instance.name=philipsBridgeImporter)");

    Instance philipsLinker = instance()
            .of(FuchsiaConstants.DEFAULT_IMPORTATION_LINKER_FACTORY_NAME)
            .with(ImportationLinker.FILTER_IMPORTDECLARATION_PROPERTY).setto("(discovery.philips.device.name=*)")
            .with(ImportationLinker.FILTER_IMPORTERSERVICE_PROPERTY).setto("(instance.name=philipsImporter)");

}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_check_if_everything_is_working">Check if everything is working</h4>
<div class="paragraph">
<p>On the shell you can type the command below, and you should obtain the list of all installed importers</p>
</div>
<div class="listingblock">
<div class="content monospaced">
<pre class="highlight"><code>user@shelbie$ importer
        ._____________________________________________
        |name:philipsImporter
        |bundle:org.ow2.chameleon.fuchsia.importer.philips-hue[17]
        |importer name = PhilipsHueImporter
        |          ._____________________________________________
        |          |factory.name = org.ow2.chameleon.fuchsia.importer.philipshue.PhilipsHueImporter
Importer|          |instance.name = philipsImporter
        |Properties|objectClass = [Ljava.lang.String;@1e10aef
        |          |service.id = 317
        |          |target = (discovery.philips.device.name=*)
        |          |_____________________________________________
        |_____________________________________________
        ._____________________________________________
        |name:philipsBridgeImporter
        |bundle:org.ow2.chameleon.fuchsia.importer.philips-hue[17]
        |importer name = PhilipsHueBridgeImporter
        |          ._____________________________________________
        |          |factory.name = org.ow2.chameleon.fuchsia.importer.philipshue.PhilipsHueBridgeImporter
Importer|          |instance.name = philipsBridgeImporter
        |Properties|objectClass = [Ljava.lang.String;@194ef9f
        |          |service.id = 315
        |          |target = (discovery.philips.bridge.type=*)
        |          |_____________________________________________
        |_____________________________________________

user@shelbie$</code></pre>
</div>
</div>
<div class="paragraph">
<p>After we can check is our linkers are all in place:</p>
</div>
<div class="listingblock">
<div class="content monospaced">
<pre class="highlight"><code>user@shelbie$ linker
                  ._____________________________________________
                  |name:philipsLinker
                  |bundle:org.ow2.chameleon.fuchsia.core[21]
                  |          ._____________________________________________
                  |          |factory.name = FuchsiaDefaultImportationLinkerFactory
                  |          |fuchsia.linker.filter.importDeclaration = (discovery.philips.device.name=*)
Importation Linker|          |fuchsia.linker.filter.importerService = (instance.name=philipsImporter)
                  |Properties|instance.name = philipsLinker
                  |          |objectClass = [Ljava.lang.String;@3e1a61
                  |          |service.id = 323
                  |          |_____________________________________________
                  |_____________________________________________
                  ._____________________________________________
                  |name:philipsLinkerBridge
                  |bundle:org.ow2.chameleon.fuchsia.core[21]
                  |          ._____________________________________________
                  |          |factory.name = FuchsiaDefaultImportationLinkerFactory
                  |          |fuchsia.linker.filter.importDeclaration = (discovery.philips.bridge.type=*)
Importation Linker|          |fuchsia.linker.filter.importerService = (instance.name=philipsBridgeImporter)
                  |Properties|instance.name = philipsLinkerBridge
                  |          |objectClass = [Ljava.lang.String;@1361707
                  |          |service.id = 321
                  |          |_____________________________________________
                  |_____________________________________________

user@shelbie$</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_testing_your_philipshue">Testing your PhilipsHue</h4>
<div class="paragraph">
<p>There are two commands to manipulate and verify the actual state of the lamp, they are: <strong>phlist</strong> and <strong>phset</strong></p>
</div>
<div class="paragraph">
<p>If your lamp was corrected detected, just type <em>phlist</em> (as below) and you should get the list of the philips light that are available along with their state.</p>
</div>
<div class="listingblock">
<div class="content monospaced">
<pre class="highlight"><code>user@shelbie$ phlist</code></pre>
</div>
</div>
<div class="paragraph">
<p>In case you wanna change its color (in fact change the color of all lamps) you can use the command <em>phset</em> as below to set the color to red:</p>
</div>
<div class="listingblock">
<div class="content monospaced">
<pre class="highlight"><code>user@shelbie$ phset -on true -r 255</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_export_jsonrpc">Export JSONRPC</h3>
<div class="sect3">
<h4 id="_goal">Goal</h4>
<div class="paragraph">
<p>Expose an OSGi service instance as a JSONRPC service that can be accessed remotely through a URL.</p>
</div>
</div>
<div class="sect3">
<h4 id="_requirements">Requirements</h4>
<div class="ulist">
<ul>
<li>
<p>service instance that will be exporter</p>
</li>
<li>
<p>declaration containing the metadata below:</p>
<div class="ulist">
<ul>
<li>
<p><strong>fuchsia.export.jsonrpc.class</strong> - full name of the interface in which your instance implements. e.g. /org.ow2.chameleon.fuchsia.jsonrpc.exporter.experiment.DummyIface/</p>
</li>
<li>
<p><strong>fuchsia.export.jsonrpc.instance</strong> - instance.name (in OSGi terms) of your service, which will be used to grab the proper instance to be exported. e.g. DummyPojoInstance</p>
</li>
<li>
<p><strong>fuchsia.export.jsonrpc.url.context</strong> (optional) - indicated the context that will be added in URL, by default "JSONRPC", which will be used as a prefix in the URL for the instance as in the example: <strong><a href="http://localhost:8080/JSONRPC/DummyPojoInstance">http://localhost:8080/JSONRPC/DummyPojoInstance</a></strong></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_example">Example</h4>
<div class="sect4">
<h5 id="_exporter_instantiation">Exporter instantiation</h5>
<div class="listingblock">
<div class="content monospaced">
<pre class="highlight"><code class="java language-java">       Instance jsonRPCExporter = instance()
                .of("org.ow2.chameleon.fuchsia.exporter.jsonrpc.JSONRPCExporter")
                .with("target").setto("(fuchsia.export.jsonrpc.instance=*)");</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_linker_instantiation">Linker instantiation</h5>
<div class="listingblock">
<div class="content monospaced">
<pre class="highlight"><code class="java language-java">        Instance jsonRPCExporterLinker = instance()
            .of(FuchsiaConstants.DEFAULT_EXPORTATION_LINKER_FACTORY_NAME)
            .with(ExportationLinker.FILTER_EXPORTDECLARATION_PROPERTY).setto("(fuchsia.export.jsonrpc.instance=*)")
            .with(ExportationLinker.FILTER_EXPORTERSERVICE_PROPERTY).setto("(instance.name=jsonRPCExporter)");</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_export_declaration_instantiation">Export Declaration instantiation</h5>
<div class="listingblock">
<div class="content monospaced">
<pre class="highlight"><code class="java language-java">
        Map&lt;String, Object&gt; metadata=new HashMap&lt;String, Object&gt;();

        metadata.put("id","exporter-1");
        metadata.put("fuchsia.export.jsonrpc.class","org.ow2.chameleon.fuchsia.jsonrpc.exporter.experiment.DummyIface");
        metadata.put("fuchsia.export.jsonrpc.instance","DummyPojoInstance");

        ExportDeclaration declaration = ExportDeclarationBuilder.fromMetadata(metadata).build();

        Dictionary&lt;String, Object&gt; props = new Hashtable&lt;String, Object&gt;();

        String clazzes[] = new String[]{org.ow2.chameleon.fuchsia.core.declaration.ExportDeclaration.class.getName()};
        ServiceRegistration registration = context.registerService(clazzes, declaration, props);
</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_verification">Verification</h4>
<div class="sect4">
<h5 id="_service_was_properly_exported">Service was properly exported</h5>
<div class="paragraph">
<p>You can use <a href="http://fr.wikipedia.org/wiki/CURL">cURL</a> to test if your instance was properly exported.</p>
</div>
<div class="listingblock">
<div class="content monospaced">
<pre class="highlight"><code class="xml language-xml">linux-shell# curl -i -X POST -d '{"jsonrpc": "2.0", "method": "helloworld", "params": ["earth"], "id": 1}' http://localhost:8080/JSONRPC/DummyPojoInstance</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>helloworld</strong> should be replaced by the method name declared on your interface to be exported</p>
</div>
<div class="paragraph">
<p><strong>earth</strong> will be replaced by the parameters requested by your interface</p>
</div>
<div class="paragraph">
<p><strong><a href="http://localhost:8080/JSONRPC/DummyPojoInstance">http://localhost:8080/JSONRPC/DummyPojoInstance</a></strong>, consider this example an instance of the pattern "http://A:B/C/D", A and B depend on your framework configuration; C is constant and will never change; D is in fact the same "instance.name" of your OSGi service instance;</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_import_jsonrpc">Import JSONRPC</h3>
<div class="sect3">
<h4 id="_goal_2">Goal</h4>
<div class="paragraph">
<p>Materialise an a remote JSONRPC service instance (available through a URL) into the current OSGi platform.</p>
</div>
</div>
<div class="sect3">
<h4 id="_requirements_2">Requirements</h4>
<div class="ulist">
<ul>
<li>
<p>URL of the JSONRPC object to be imported</p>
</li>
<li>
<p>declaration containing the metadata below:</p>
<div class="ulist">
<ul>
<li>
<p><strong>id</strong> - a platform unique identifier</p>
</li>
<li>
<p><strong>url</strong> - URL where the object was published. e.g. <a href="http://localhost:8080/JSONRPC/DummyPojoInstance">http://localhost:8080/JSONRPC/DummyPojoInstance</a></p>
</li>
<li>
<p><strong>service.class</strong> - full class identifier used as interface, this reference will be used to register in OSGi. e.g. org.ow2.chameleon.fuchsia.examples.jsonrpc.exporter.experiment.DummyIface</p>
</li>
<li>
<p><strong>configs</strong> - this is a constant, always set with the value <strong>jsonrpc</strong></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_example_2">Example</h4>
<div class="sect4">
<h5 id="_importer_instantiation">Importer instantiation</h5>
<div class="listingblock">
<div class="content monospaced">
<pre class="highlight"><code class="java language-java">     Instance jsonRPCImporter = instance()
            .of("Fuchsia-Importer:JSON-RPC")
            .with(ImporterService.TARGET_FILTER_PROPERTY).setto("(configs=jsonrpc)");</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_linker_instantiation_2">Linker instantiation</h5>
<div class="listingblock">
<div class="content monospaced">
<pre class="highlight"><code class="java language-java">        Instance jsonRPCImporterLinker = instance()
            .of(FuchsiaConstants.DEFAULT_IMPORTATION_LINKER_FACTORY_NAME)
            .with(FILTER_IMPORTDECLARATION_PROPERTY).setto("(configs=jsonrpc)")
            .with(FILTER_IMPORTERSERVICE_PROPERTY).setto("(instance.name=jsonRPCImporter)");</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_importer_declaration_instantiation">Importer Declaration instantiation</h5>
<div class="listingblock">
<div class="content monospaced">
<pre class="highlight"><code class="java language-java">        Map&lt;String, Object&gt; metadata=new HashMap&lt;String, Object&gt;();
        metadata.put(ID, "endipoint");
        metadata.put(URL, "http://localhost:8080/JSONRPC/DummyPojoInstance");
        metadata.put(SERVICE_CLASS, "org.ow2.chameleon.fuchsia.examples.jsonrpc.exporter.experiment.DummyIface");
        metadata.put(CONFIGS, "jsonrpc");

        ImportDeclaration declaration = ImportDeclarationBuilder.fromMetadata(metadata).build();

        String clazzes[] = new String[]{ImportDeclaration.class.getName()};

        Dictionary&lt;String, Object&gt; props = new Hashtable&lt;String, Object&gt;();

        ServiceRegistration registration = context.registerService(clazzes, declaration, props);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_verification_2">Verification</h4>
<div class="sect4">
<h5 id="_service_was_properly_imported">Service was properly imported</h5>
<div class="paragraph">
<p>You can use <strong>felix shelbie shell</strong> and inspect the importer bundle to check if it has correcly imported our JSONRPC remote instance</p>
</div>
<div class="listingblock">
<div class="content monospaced">
<pre class="highlight"><code class="xml language-xml">shelbie-shell$ lb
..
   31|Active     |    1|OW2 Chameleon - Fuchsia Importer JSON-RPC (0.0.2.SNAPSHOT)
..
shelbie-shell$ inspect cap service 31
...
service; org.ow2.chameleon.fuchsia.examples.jsonrpc.exporter.experiment.DummyIface with properties:
   service.id = 693
</code></pre>
</div>
</div>
<div class="paragraph">
<p>Importer should provide a service with the interface that we&#8217;d configured just before in the <strong>Importer Declaration instantiation</strong>.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_export_jaxws">Export JAXWS</h3>
<div class="sect3">
<h4 id="_goal_3">Goal</h4>
<div class="paragraph">
<p>Expose an OSGi service instance as a JAXWS service that can be accessed remotely through a URL.</p>
</div>
</div>
<div class="sect3">
<h4 id="_requirements_3">Requirements</h4>
<div class="ulist">
<ul>
<li>
<p>service instance that will be exporter</p>
</li>
<li>
<p>declaration containing the metadata below:</p>
<div class="ulist">
<ul>
<li>
<p><strong>fuchsia.export.cxf.class.name</strong> - full name of the interface in which your instance implements. e.g. /org.ow2.chameleon.fuchsia.exporter.cxf.examples.base.PojoSampleToBeExportedIface/</p>
</li>
<li>
<p><strong>fuchsia.export.cxf.instance</strong> - instance.name (in OSGi terms) of your service, which will be used to grab the proper instance to be exported. e.g. DummyPojoInstance</p>
</li>
<li>
<p><strong>fuchsia.export.cxf.url.context</strong> - indicated the context that will be added in URL, which will be used as a prefix in the URL for the instance as in the example: <strong>/PojoSampleToBeExported</strong></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_example_3">Example</h4>
<div class="sect4">
<h5 id="_exporter_instantiation_2">Exporter instantiation</h5>
<div class="listingblock">
<div class="content monospaced">
<pre class="highlight"><code class="java language-java">    Instance cxfexporter = instance()
            .of("org.ow2.chameleon.fuchsia.exporter.jaxws.JAXWSExporter")
            .with("target").setto("(fuchsia.export.cxf.instance=*)");</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_linker_instantiation_3">Linker instantiation</h5>
<div class="listingblock">
<div class="content monospaced">
<pre class="highlight"><code class="java language-java">    Instance cxfexporterlinker = instance()
            .of(FuchsiaConstants.DEFAULT_EXPORTATION_LINKER_FACTORY_NAME)
            .with(ExportationLinker.FILTER_EXPORTDECLARATION_PROPERTY).setto("(fuchsia.export.cxf.instance=*)")
            .with(ExportationLinker.FILTER_EXPORTERSERVICE_PROPERTY).setto("(instance.name=cxfexporter)");</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_export_declaration_instantiation_2">Export Declaration instantiation</h5>
<div class="listingblock">
<div class="content monospaced">
<pre class="highlight"><code class="java language-java">
        Map&lt;String, Object&gt;  metadata=new HashMap&lt;String, Object&gt;();

        metadata.put("id","a");
        metadata.put("exporter.id","myservice");
        metadata.put("fuchsia.export.cxf.class.name",dummyInstance.getClass().getName());
        metadata.put("fuchsia.export.cxf.instance",dummyInstance);
        metadata.put("fuchsia.export.cxf.url.context","/PojoSampleToBeExported");

        ExportDeclaration declaration = ExportDeclarationBuilder.fromMetadata(metadata).build();

        Dictionary&lt;String, Object&gt; props = new Hashtable&lt;String, Object&gt;();
        String clazzes[] = new String[]{org.ow2.chameleon.fuchsia.core.declaration.ExportDeclaration.class.getName()};
        ServiceRegistration registration = context.registerService(clazzes, declaration, props);
</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_verification_3">Verification</h4>
<div class="sect4">
<h5 id="_service_was_properly_exported_2">Service was properly exported</h5>
<div class="paragraph">
<p>Try to access the URL <strong><a href="http://localhost:8080/cxf/PojoSampleToBeExported?wsdl">http://localhost:8080/cxf/PojoSampleToBeExported?wsdl</a></strong> this should show you the WSDL of the service exported</p>
</div>
<div class="paragraph">
<p>Of course that this URL is based on the example created above, if you changed the property "fuchsia.export.cxf.url.context" (which it is always the case) you have to replace the "PojoSampleToBeExported" on the URL by the proper name.</p>
</div>
<div class="paragraph">
<p>You should see something like:</p>
</div>
<div class="listingblock">
<div class="content monospaced">
<pre class="highlight"><code class="xml language-xml">&lt;wsdl:definitions xmlns:ns1="http://schemas.xmlsoap.org/soap/http" xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/" xmlns:tns="http://base.examples.cxf.exporter.fuchsia.chameleon.ow2.org/" xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/" xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="PojoSampleToBeExported" targetNamespace="http://base.examples.cxf.exporter.fuchsia.chameleon.ow2.org/"&gt;
...
&lt;/wsdl:service&gt;
&lt;/wsdl:definitions&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_import_jaxws">Import JAXWS</h3>
<div class="sect3">
<h4 id="_goal_4">Goal</h4>
<div class="paragraph">
<p>Materialise an a remote JAXWS service instance (available through a URL) into the current OSGi platform.</p>
</div>
</div>
<div class="sect3">
<h4 id="_requirements_4">Requirements</h4>
<div class="ulist">
<ul>
<li>
<p>URL of the JAXWS (SOAP) object to be imported</p>
</li>
<li>
<p>declaration containing the metadata below:</p>
<div class="ulist">
<ul>
<li>
<p><strong>id</strong> - a platform unique identifier</p>
</li>
<li>
<p><strong>endpoint.url</strong> - URL where the object was published. e.g. <strong><a href="http://localhost:8080/cxf/PojoSampleToBeExported">http://localhost:8080/cxf/PojoSampleToBeExported</a></strong></p>
</li>
<li>
<p><strong>className</strong> - full class identifier used as interface, this reference will be used to register in OSGi. e.g. <strong>org.ow2.chameleon.fuchsia.exporter.cxf.examples.base.PojoSampleToBeExportedIface</strong></p>
</li>
<li>
<p><strong>configs</strong> - this is a constant, always set with the value <strong>jsonrpc</strong></p>
</li>
<li>
<p><strong>jax-ws.importer.interfaces</strong> (optional) - interfaces that will charged by the importer</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_example_4">Example</h4>
<div class="sect4">
<h5 id="_importer_instantiation_2">Importer instantiation</h5>
<div class="listingblock">
<div class="content monospaced">
<pre class="highlight"><code class="java language-java">    Instance cxfimporter = instance()
            .of("org.ow2.chameleon.fuchsia.importer.jaxws.JAXWSImporter")
            .named("cxfimporter")
            .with("target").setto("(endpoint.url=*)");</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_linker_instantiation_4">Linker instantiation</h5>
<div class="listingblock">
<div class="content monospaced">
<pre class="highlight"><code class="java language-java">    Instance cxfimporterlinker = instance()
            .of(FuchsiaConstants.DEFAULT_IMPORTATION_LINKER_FACTORY_NAME)
            .named("cxfimporterlinker")
            .with(FILTER_IMPORTDECLARATION_PROPERTY).setto("(endpoint.url=*)")
            .with(FILTER_IMPORTERSERVICE_PROPERTY).setto("(instance.name=cxfimporter)");</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_importer_declaration_instantiation_2">Importer Declaration instantiation</h5>
<div class="listingblock">
<div class="content monospaced">
<pre class="highlight"><code class="java language-java">        Map&lt;String, Object&gt;  metadata=new HashMap&lt;String, Object&gt;();

        metadata.put("id","b");
        metadata.put("className","org.ow2.chameleon.fuchsia.exporter.cxf.examples.base.PojoSampleToBeExportedIface");
        metadata.put("jax-ws.importer.interfaces","[org.ow2.chameleon.fuchsia.exporter.cxf.examples.base.PojoSampleToBeExportedIface]");
        metadata.put("endpoint.url","http://localhost:8080/cxf/PojoSampleToBeExported");

        ImportDeclaration declaration = ImportDeclarationBuilder.fromMetadata(metadata).build();

        Dictionary&lt;String, Object&gt; props = new Hashtable&lt;String, Object&gt;();
        props.put("endpoint.url","http://localhost:8080/cxf/PojoSampleToBeExported");
        String clazzes[] = new String[]{ImportDeclaration.class.getName()};
        ServiceRegistration registration = context.registerService(clazzes, declaration, props);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_verification_4">Verification</h4>
<div class="sect4">
<h5 id="_service_was_properly_imported_2">Service was properly imported</h5>
<div class="paragraph">
<p>You can use <strong>felix shelbie shell</strong> and inspect the importer bundle to check if it has correcly imported our JAXWS remote instance</p>
</div>
<div class="listingblock">
<div class="content monospaced">
<pre class="highlight"><code class="xml language-xml">shelbie-shell$ lb
..
   52|Active     |    1|OW2 Chameleon - Fuchsia Importer JAX-WS (0.0.2.SNAPSHOT)
..
shelbie-shell$ inspect cap service 52 # you should find something similar to this output
...
service; org.ow2.chameleon.fuchsia.exporter.cxf.examples.base.PojoSampleToBeExportedIface</code></pre>
</div>
</div>
<div class="paragraph">
<p>Importer should provide a service with the interface that we&#8217;d configured just before in the <strong>Importer Declaration instantiation</strong>.</p>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2014-04-04 14:29:31 CEST
</div>
</div>
</body>
</html>