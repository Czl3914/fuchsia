<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="generator" content="Asciidoctor 0.1.3">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Fuchsia</title>
<link rel="stylesheet" href="./stylesheets/asciidoc.css">
</head>
<body class="article">
<div id="header">
<h1>Fuchsia</h1>
<div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ol type="none" class="sectlevel1">
<li><a href="#_what_is_fuchsia">What is Fuchsia?</a></li>
<li>
<ol type="none" class="sectlevel2">
<li><a href="#_declarations">Declarations</a></li>
<li><a href="#_discoveries">Discoveries</a></li>
<li><a href="#_processors">Processors</a></li>
<li><a href="#_linkers">Linkers</a></li>
</ol>
</li>
<li><a href="#_creating_a_fuchsia_distribution">Creating a fuchsia distribution</a></li>
<li>
<ol type="none" class="sectlevel2">
<li><a href="#_fuchsia_core">Fuchsia core</a></li>
<li><a href="#_discoveries_2">Discoveries</a></li>
<li><a href="#_importers_2">Importers</a></li>
<li><a href="#_exporters_2">Exporters</a></li>
<li><a href="#_tools">Tools</a></li>
<li><a href="#_config_profiles">Config profiles</a></li>
</ol>
</li>
<li><a href="#_advanced_how_to_instantiate_an_importer">Advanced, how to instantiate an importer</a></li>
<li><a href="#_importers_3">Importers</a></li>
<li>
<ol type="none" class="sectlevel2">
<li><a href="#_fake_importer">Fake importer</a></li>
<li><a href="#_jax_ws_importer">JAX-WS importer</a></li>
<li><a href="#_mqtt_importer">MQTT importer</a></li>
<li><a href="#_pubsubhubbub_importer">PubSubHubBub importer</a></li>
<li><a href="#_detailed_description">Detailed Description</a></li>
</ol>
</li>
<li><a href="#_examples">Examples</a></li>
<li>
<ol type="none" class="sectlevel2">
<li><a href="#_discovery">Discovery</a></li>
</ol>
</li>
</ol>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_what_is_fuchsia">What is Fuchsia?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><span class="image"><a class="image" href="diagram/importer01.svg"><img src="diagram/importer01.svg" alt="Fuchsia" width="1024"></a></span></p>
</div>
<div class="paragraph">
<p>Fuchsia is an extensible tool for integrating external communication protocols inside an OSGi platform. It provides a common interface for creating and managing external connections.</p>
</div>
<div class="paragraph">
<p>As most of modern applications require multiple sources of information such as web services, databases or ubiquitous devices. The integration among those different services become a major issue when dealing with multitude of them.</p>
</div>
<div class="paragraph">
<p>In ubiquitous applications this kind of integration is even more important since the dynamicity and the multitude of protocol grows with number of devices supported.</p>
</div>
<div class="paragraph">
<p>So, developers are suddenly facing the challenge of mastering several protocol, and their respective tools for debugging, dependency managing, native calls access, access configuration, etc. That is where Fuchsia plays a key role, by providing the same way of dealing with different protocols, creating a single entrypoint for all protocols supported.</p>
</div>
<div class="paragraph">
<p>In Appsgate all those characteristics are gathered in order to provide an Smart Home environment.</p>
</div>
<div class="paragraph">
<p>You can administrate and monitor all the exchange of your OSGi platform with externals protocols through an unique control panel.</p>
</div>
<div class="ulist">
<div class="title">There exist essentially 4 types of entities inside fuchsia that you need to understand before go hands-on the code:</div>
<ul>
<li>
<p>Declaration, it is the metadata that describes a device or a service</p>
</li>
<li>
<p>Discovery, responsible for the detection of a device/service, in Fuchsia that means create a <strong>Declaration</strong> and adding it to the osgi registry</p>
</li>
<li>
<p>Processors, it represents the task itself.</p>
</li>
<li>
<p>Linkers, connects a declaration to a processor, evaluate the constraints to be respected in order to connect those two.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_declarations">Declarations</h3>
<div class="paragraph">
<p>Think in <strong>Declaration</strong> as a property file, although that it is not a file, it is an service registered in an OSGi platform, as long as this service is registered with the proper platform, <strong>Fuchsia</strong> will recognize it.</p>
</div>
<div class="paragraph">
<p>Its function is to indicate that a given device/service is available with certain properties, and is the role of an Importer/Exporter (explained later) to receive those information as inputs and create a bridge between the osgi platform and this device (all by using the properties given by the <strong>Declaration</strong>), allowing other services to access this device without knowing its protocol.</p>
</div>
</div>
<div class="sect2">
<h3 id="_discoveries">Discoveries</h3>
<div class="paragraph">
<p>As seen before, the way that we inform the Fuchsia platform the existence of a device/service is through a declaration <strong>Declaration</strong>, that can be registered manually of course (since its a service registered in OSGi platform with the interface <strong>org.ow2.chameleon.fuchsia.core.declaration.ImportDeclaration</strong>), but this can be done by fuchsia discoveries, that use specialized discovery protocols to extract all the relevant information of a given service/device and publish in OSGi platform a <strong>Declaration</strong> containing all those informations.</p>
</div>
<div class="ulist">
<div class="title">Available discovery implementations:</div>
<ul>
<li>
<p>Fake discovery</p>
</li>
<li>
<p>mDNS/DNSsd</p>
</li>
<li>
<p>uPnP</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_processors">Processors</h3>
<div class="sect3">
<h4 id="_importers">Importers</h4>
<div class="paragraph">
<p>In order to trigger <strong>importers</strong> to perform their job, they must to receive an <strong>import declaration</strong> which is configuration (think of it as a key value mapping, just like java properties). The <strong>importation declaration</strong> will recognized by <strong>Fuchsia</strong> as long as they are registered in OSGi with the proper Fuchsia interface (for an importer for example must be <strong>org.ow2.chameleon.fuchsia.core.declaration.ImportDeclaration</strong> )</p>
</div>
<div class="ulist">
<div class="title">Available implementations:</div>
<ul>
<li>
<p>Fake importer</p>
</li>
<li>
<p>JAX-RS</p>
</li>
<li>
<p>JAX-WS</p>
</li>
<li>
<p>JSON-RPC</p>
</li>
<li>
<p>MQTT</p>
</li>
<li>
<p>PUbSubHubBub</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_exporters">Exporters</h4>
<div class="paragraph">
<p>Analogue to the <strong>importers</strong>, the <strong>exporters</strong> must to receive a <strong>declaration</strong>, but in this case an <strong>export declaration</strong>. But its role is to provide an external access (by external meaning externally to the OSGi platform) to the services available in the current OSGi platform, for instance by publishing a WS.</p>
</div>
<div class="ulist">
<div class="title">Available implementations:</div>
<ul>
<li>
<p>JAX-WS</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_linkers">Linkers</h3>
<div class="paragraph">
<p>The existence of a <strong>declaration</strong> and a <strong>processor</strong> is not enough to trigger a connection is established between them, in order to do so there exist the <strong>linkers</strong>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_creating_a_fuchsia_distribution">Creating a fuchsia distribution</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In order to generate a Fuchsia distribution there is only one mandatory profile the <strong>core</strong>, all the other modules are optional and can be included in the distribution by adding the apropriate maven profile ( <strong>mvn -P parameter</strong> ). The maven profile and its contents are specified right below.</p>
</div>
<div class="sect2">
<h3 id="_fuchsia_core">Fuchsia core</h3>
<div class="ulist">
<ul>
<li>
<p>core - This module contains all the basic Fuchsia types, fuchsia shell tool is installed automatically in this profile as well, even though its not part of the bundle core</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_discoveries_2">Discoveries</h3>
<div class="ulist">
<ul>
<li>
<p><a href="http://jmdns.sourceforge.net/">mdns</a> - the implementation os dnssd/mdns discovery protocol</p>
</li>
<li>
<p>upnp</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_importers_2">Importers</h3>
<div class="ulist">
<ul>
<li>
<p>importer-cxf</p>
</li>
<li>
<p><a href="http://mqtt.org/">mqtt</a></p>
</li>
<li>
<p><a href="https://code.google.com/p/pubsubhubbub/">push</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_exporters_2">Exporters</h3>
<div class="ulist">
<ul>
<li>
<p>exporter-cxf</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_tools">Tools</h3>
<div class="ulist">
<ul>
<li>
<p>grid</p>
</li>
<li>
<p>fake</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_config_profiles">Config profiles</h3>
<div class="ulist">
<ul>
<li>
<p>discoveries:</p>
<div class="ulist">
<ul>
<li>
<p>mdns-config</p>
</li>
</ul>
</div>
</li>
<li>
<p>importers:</p>
<div class="ulist">
<ul>
<li>
<p>importer-cxf-config</p>
</li>
<li>
<p>mqtt-config</p>
</li>
<li>
<p>push-config</p>
</li>
</ul>
</div>
</li>
<li>
<p>exporters:</p>
<div class="ulist">
<ul>
<li>
<p>exporter-cxf-config</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Thus, in order to compile Fuchsia with the <strong>grid</strong>, <strong>exporter-cxf</strong> and <strong>mqtt</strong>, would be enough to:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>go to the <strong>distribution</strong> directory</p>
</li>
<li>
<p>type <strong>mvn -Pcore,grid,exporter-cxf,mqtt</strong></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>After the compilation process is finished, your Fuchsia distribution is ready to use:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>go to the <strong>distribution/target/chameleon-distribution/</strong></p>
</li>
<li>
<p>type <strong>./chameleon.sh --interactive</strong> (or the apropriate script according to your OS)</p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_advanced_how_to_instantiate_an_importer">Advanced, how to instantiate an importer</h2>
<div class="sectionbody">
</div>
</div>
<div class="sect1">
<h2 id="_importers_3">Importers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>As seen in [Fuchsia 101](Fuchsia-101), importers use <strong>import declaration</strong> as input. The information contained in the <strong>import declaration</strong> must be enough in order that the processor execute its role properly.</p>
</div>
<div class="sect2">
<h3 id="_fake_importer">Fake importer</h3>
<div class="paragraph">
<p>As soon as this <strong>importer</strong> is connected to an <strong>import declaration</strong> it generates an instance of Fuchsia <strong>GenericDevice</strong>, and this instance is published as a service inside OSGi platform.</p>
</div>
</div>
<div class="sect2">
<h3 id="_jax_ws_importer">JAX-WS importer</h3>
<div class="ulist">
<div class="title">External Requirement:</div>
<ul>
<li>
<p>JAX-WS service published</p>
</li>
<li>
<p>Interface(a') that represents the WSDL available in the OSGi platform that will import the service</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">Import Declaration information required:</div>
<ul>
<li>
<p>jax-ws.importer.interfaces</p>
</li>
<li>
<p>className</p>
</li>
<li>
<p>endpoint.url</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">Output:</div>
<ul>
<li>
<p>OSGi service registered with a' representing the JAX-WS (Remote service)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Detailed Description</strong></p>
</div>
<div class="paragraph">
<p>Today to import the JAX-WS service Fushsia uses <a href="http://cxf.apache.org/">CXF</a>. CXF is used in order to reduce the complexity in creating the connection and handling with different issues that may be raised.</p>
</div>
</div>
<div class="sect2">
<h3 id="_mqtt_importer">MQTT importer</h3>
<div class="ulist">
<div class="title">External Requirement:</div>
<ul>
<li>
<p>MQTT server with the address known</p>
</li>
<li>
<p>EventAdmin service configured in the machine that will import this service</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">Import Declaration information required:</div>
<ul>
<li>
<p>id</p>
</li>
<li>
<p>mqtt.queue</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">Output:</div>
<ul>
<li>
<p>A message will be published in EventAdmin in the queue $mqtt.queue, meaning that it will use the same name of <strong>queue</strong> as MQTT</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Detailed Description</strong></p>
</div>
<div class="paragraph">
<p><a href="http://mqtt.org/">MQTT</a> is a protocol <a href="http://openiot.eu/">largely diffused</a> protocole for message exchange due to its good performance. The implementation used by Fuchsia to support MQTT was <a href="http://www.rabbitmq.com/">RabbitMQ</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_pubsubhubbub_importer">PubSubHubBub importer</h3>
<div class="paragraph">
<p><a href="http://code.google.com/p/pubsubhubbub/">PubSubHubBub</a>, or simply <strong>PuSH</strong>, is a publish/subscribe protocol created by google and used by some of its <a href="http://code.google.com/p/pubsubhubbub/wiki/HubbubAtGoogle">tools</a>.</p>
</div>
<div class="ulist">
<div class="title">External Requirement:</div>
<ul>
<li>
<p>PuSh server address</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">Import Declaration information required:</div>
<ul>
<li>
<p>push.hub.url</p>
</li>
<li>
<p>push.hub.topic</p>
</li>
<li>
<p>push.subscriber.callback</p>
</li>
<li>
<p>push.eventAdmin.queue</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">Output:</div>
<ul>
<li>
<p>A message will be published in EventAdmin in the queue $push.eventAdmin.queue, meaning that it will use the same name of <strong>queue</strong> as PuSH</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_detailed_description">Detailed Description</h3>
<div class="paragraph">
<p>There are no well known and portable PuSH implementations, Fuchsia implemented partially <a href="https://pubsubhubbub.googlecode.com/git/pubsubhubbub-core-0.4.html">PuSH specification</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_examples">Examples</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_discovery">Discovery</h3>
<div class="paragraph">
<p>First things first, in order to have an discovery we need to create a fuchsia distribution that embbeds it, or to use an already existing distribution and add the modules required. Below we ll show you how to use couples of discoveries that are available in the platform.</p>
</div>
<div class="sect3">
<h4 id="_fake_discovery">Fake Discovery</h4>
<div class="paragraph">
<p>As seen in the introduction the fundamental task of a discovery is to create an instance of Declaration which represents the availability of a service/device, and the intrinsic information of such service/device are contained inside <strong>Declaration</strong> as properties (stored in a Map).</p>
</div>
<div class="paragraph">
<p>The idea behind having a fake discovery, is in infact be able to deploy a file (property file style, containing key value mapping).</p>
</div>
<div class="paragraph">
<p>In order to activate the fake discovery its enough to compile the distribution with the profile <strong>fake</strong> (meaning mvn clean install -Pcore,fake), from the moment you compile a distribution with this parameter and you launch this distribution a directory called <strong>load</strong> will be created in the root of the chameleon distribution ($FUCHSIA/distribution/target/chameleon-distribution), this directory will be used to deploy your files that contain the key-value that you need to be instantiated in the platform.</p>
</div>
<div class="paragraph">
<p>An example of such file is this one:</p>
</div>
<div class="listingblock">
<div class="content monospaced">
<pre>id=mqtt-dispatch-event-admin
exporter.id=camera-exporter

deviceType=camera
deviceSubType=another

mqtt.queue=public</pre>
</div>
</div>
<div class="paragraph">
<p>If you type <strong>declaration</strong> in the console you should see:</p>
</div>
<div class="listingblock">
<div class="content monospaced">
<pre>Service properties:
		objectClass = [Ljava.lang.String;@26f6a1
		service.id = 319
Metadata
	id=mqtt-dispatch-event-admin
	deviceType=camera
	deviceSubType=another
	exporter.id=camera-exporter
	mqtt.queue=public</pre>
</div>
</div>
<div class="paragraph">
<p>This indicated that the file that you have just deployed have been read and turned into a declaration.</p>
</div>
</div>
<div class="sect3">
<h4 id="_mdns">mDNS</h4>
<div class="paragraph">
<p>mDNS is a discovery protocol based on the previous Bonjour(c), from Apple. To perform a simple test of such protocol, its enough to compile a fuchsia distribution with the following parameters:</p>
</div>
<div class="paragraph">
<p><em>mvn clean install -Pcore,mdns,mdns-config</em></p>
</div>
<div class="paragraph">
<p>core and mdns are the modules that we need, in this case, the fuchsia core types and the discovery module itself. The 3td element <em>mdns-config</em> is the element responsible to configure the discovery. Even though the <strong>mdns</strong> module is available with the -Pmdns profile, it is necessary to create an instance of it, shaping it as we wish. We will explain in few paragraphs how to do that manually, but for now we will use an configuration example that setup the discovery to findout all the printers available in the local network, for that we add the profile -Pmdns-config.</p>
</div>
<div class="paragraph">
<p>To verify that the discovery works properly you can use the console.</p>
</div>
<div class="paragraph">
<p>If you type <strong>declaration</strong> on the console you should see an output similar to this:</p>
</div>
<div class="paragraph">
<p>You should see all your printers in form of:</p>
</div>
<div class="listingblock">
<div class="content monospaced">
<pre>Metadata
	id=hp LaserJet 2300 (scribe missions)
	discovery.mdns.device.name=hp LaserJet 2300 (scribe missions)
Metadata
	id=HP LaserJet 600 M602 [2F0B40]
	discovery.mdns.device.name=HP LaserJet 600 M602 [2F0B40]
	Service properties:
		objectClass = [Ljava.lang.String;@fcc720
		service.id = 312
...</pre>
</div>
</div>
<div class="paragraph">
<p>And if you type <strong>discovery</strong> in the console you should see:</p>
</div>
<div class="listingblock">
<div class="content monospaced">
<pre>Discovery [DNSSDDiscovery] provided by bundle mdns (19)
	Service properties:
		dnssd.service.type = _printer._tcp.local.
		factory.name = DNSSDDiscoveryFactory
		instance.name = DNSSDDiscovery
		objectClass = [Ljava.lang.String;@1db4108
		service.id = 301</pre>
</div>
</div>
<div class="paragraph">
<p>In this approach we used a configuration that was available in Fuchsia. But that is not usually the case; most of the time we are required to instantiate the discovery ourselves configure the filter in a way that is the application need it.</p>
</div>
<div class="paragraph">
<p>The following configuration that makes available to import all the printers on the local network inside the platform with requiring any other information than the type of the device that interest us.</p>
</div>
<div class="listingblock">
<div class="content monospaced">
<pre>@Configuration
public class DNSSDInitializer {
    Instance dnssdDiscovery = instance()
            .of("DNSSDDiscoveryFactory")
            .named("DNSSDDiscovery")
            .with("dnssd.service.type").setto("_printer._tcp.local.");

}</pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<img src="./images/icons/tip.png" alt="Tip">
</td>
<td class="content">
<div class="paragraph">
<p>This instance can be created in any fashion, as long as it is an <a href="http://www.ipojo.org">iPOJO</a> instance.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2013-11-28 13:15:51 CET
</div>
</div>
</body>
</html>